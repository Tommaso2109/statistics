<!DOCTYPE HTML>
<html>
    <head>
        <title>Tommaso Rinaldi 1983126</title>
        <meta charset="utf-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no" />
        <link rel="stylesheet" href="homework_Style.css" />
        <noscript><link rel="stylesheet" href="noscript.css" /></noscript>
    </head>
    <body>
        <header class="main-header">
			 <div class="profile-photo">
                <img src="profile_pic.jpg" alt="Profile Photo">
            </div>
            
            <div class="header-title">
                <h1>Statistics Homework</h1>
                <h2>Tenth Homework</h2>  
            </div>

            <div class="header-home-btn">
                <a href="index.html">
                    <button class="Btn">
    
                        <div class="sign"><svg xmlns="http://www.w3.org/2000/svg" 
                            viewBox="0 0 24 24" 
                            width="240" 
                            height="240" 
                            fill="black">
                        <path d="M12 3l10 8h-3v9a1 1 0 0 1-1 1h-5v-6H11v6H6a1 1 0 0 1-1-1v-9H2l">

                        </svg>
                        

                        
                        <div class="text">HOME</div>
                    </button>
                </a>
            </div>

        </header>
        <main>
            <section id="poisson-approx">
                <h2>Simulation: Bernoulli approximation of a Poisson process</h2>

                <p>This page contains an interactive simulation of the Bernoulli approximation to a homogeneous Poisson process on the interval [0, T]. You can set parameters (rate λ, interval length T, number of subintervals n and number of trials) and run the simulation directly in your browser. Results include empirical mean/variance of counts and histograms for counts and interarrival times.</p>

                <div class="sim-controls">
                    <label>λ (rate): <input type="number" id="lambda" step="0.1" value="3.5"></label>
                    <label>T: <input type="number" id="T" step="0.1" value="1"></label>
                    <label>n (subintervals): <input type="number" id="n" step="1" value="5000"></label>
                    <label>trials: <input type="number" id="trials" step="1" value="2000"></label>
                    <button id="runBtn">Run simulation</button>
                    <span id="status" style="margin-left:1em;color:#666"></span>
                </div>

                <h3>Numeric results</h3>
                <div id="results">
                    <p>Run a simulation to see results here.</p>
                </div>

                <h3>Histograms</h3>
                <div style="max-width:800px; width:100%;">
                    <canvas id="countsHist" width="700" height="200" style="border:1px solid #ccc; width:100%; max-width:700px; height:220px; display:block"></canvas>
                    <canvas id="iaHist" width="700" height="200" style="border:1px solid #ccc; margin-top:12px; width:100%; max-width:700px; height:220px; display:block"></canvas>
                </div>

                <div id="hist-explanations" style="max-width:800px; width:100%; margin-top:10px; color:#222;">
                    <h4>What these plots show</h4>
                    <p><strong>Counts histogram:</strong> the top plot shows the empirical distribution of the number of events observed in the interval [0, T] across all trials. The blue gradient bars represent the empirical probability per bin. The red curve and markers overlay the theoretical Poisson probability mass function with mean λT — agreement indicates the Binomial(n, p) approximation is close to Poisson(λT).</p>
                    <p><strong>Interarrival histogram:</strong> the lower plot displays empirical interarrival times from one example realization (successes placed uniformly within their subintervals). The red curve overlays the theoretical Exponential(pdf) with rate λ. To estimate the exponential law accurately you should collect many interarrival times across many realizations (or directly simulate exponential interarrivals).</p>
                    <p style="font-size:0.9em;color:#ffffff">Notes: small discrepancies can come from finite-sample variability, binning choices, and the finite subinterval width n (for very small n the approximation worsens). Increasing trials and n (while keeping p = λT/n small) improves agreement.</p>
                </div>

                <p style="font-size:0.9em;color:#ffffff">Notes: The browser-based simulation can be computationally heavy if you set <code>trials</code> and <code>n</code> very large. Defaults are conservative but representative. For large-scale experiments use the Python scripts in the repository.</p>
            </section>

            <script>
            // Browser-side simulation script
            (function(){
                function mean(arr){ return arr.reduce((a,b)=>a+b,0)/arr.length; }
                function variance(arr, mu){ mu = (mu===undefined)? mean(arr): mu; return arr.reduce((s,x)=>s+(x-mu)*(x-mu),0)/arr.length; }

                const runBtn = document.getElementById('runBtn');
                const status = document.getElementById('status');
                const resultsDiv = document.getElementById('results');
                const countsCanvas = document.getElementById('countsHist');
                const iaCanvas = document.getElementById('iaHist');

                function drawHistogram(canvas, data, options){
                    // make canvas responsive: size to CSS layout and use devicePixelRatio for crisp rendering
                    const ctx = canvas.getContext('2d');
                    const dpr = window.devicePixelRatio || 1;
                    const rect = canvas.getBoundingClientRect();
                    const w = rect.width;
                    const h = rect.height;
                    canvas.width = Math.round(w * dpr);
                    canvas.height = Math.round(h * dpr);
                    canvas.style.width = w + 'px';
                    canvas.style.height = h + 'px';
                    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
                    ctx.clearRect(0,0,w,h);
                    if(!data || data.length===0) return;
                    const pad = 40;
                    const bins = options.bins || Math.min(60, Math.ceil(Math.sqrt(data.length)));

                    // compute min/max and histogram
                    let min = Math.min(...data), max = Math.max(...data);
                    if(min === max){ min = min - 0.5; max = max + 0.5; }
                    const binWidth = (max - min + 1e-12)/bins;
                    const counts = new Array(bins).fill(0);
                    data.forEach(v=>{ const i = Math.min(bins-1, Math.floor((v-min)/binWidth)); counts[i]++; });

                    // convert to probability mass / density depending on type
                    const probs = new Array(bins);
                    for(let i=0;i<bins;i++) probs[i] = counts[i] / data.length; // probability mass per bin

                    // find max for scaling
                    const maxVal = Math.max(...probs);

                    // draw background grid
                    ctx.fillStyle = '#fff'; ctx.fillRect(0,0,w,h);
                    ctx.strokeStyle = '#eee';
                    ctx.lineWidth = 1;
                    const gridLines = 4;
                    for(let g=0; g<=gridLines; g++){
                        const y = pad + g*(h-2*pad)/gridLines;
                        ctx.beginPath(); ctx.moveTo(pad, y); ctx.lineTo(w-pad, y); ctx.stroke();
                    }

                    // draw bars with gradient
                    const bw = (w - 2*pad) / bins;
                    const grad = ctx.createLinearGradient(0, pad, 0, h-pad);
                    grad.addColorStop(0, '#7fb3ff'); grad.addColorStop(1, '#1f6fbf');
                    for(let i=0;i<bins;i++){
                        const barH = (probs[i] / maxVal) * (h - 2*pad);
                        const x = pad + i * bw;
                        const y = h - pad - barH;
                        ctx.fillStyle = grad;
                        // rounded top for visual
                        ctx.beginPath();
                        ctx.moveTo(x, h-pad);
                        ctx.lineTo(x, y+4);
                        ctx.quadraticCurveTo(x + bw/2, y, x + bw, y+4);
                        ctx.lineTo(x + bw, h-pad);
                        ctx.closePath();
                        ctx.fill();
                        // subtle border
                        ctx.strokeStyle = 'rgba(0,0,0,0.06)'; ctx.stroke();
                    }

                    // axes
                    ctx.strokeStyle = '#333'; ctx.lineWidth = 1.2;
                    ctx.beginPath(); ctx.moveTo(pad, pad); ctx.lineTo(pad, h-pad); ctx.lineTo(w-pad, h-pad); ctx.stroke();

                    // y-axis ticks and labels
                    ctx.fillStyle = '#333'; ctx.font = '12px sans-serif';
                    const yticks = 4;
                    for(let t=0;t<=yticks;t++){
                        const val = (1 - t/yticks) * maxVal;
                        const y = pad + t*(h-2*pad)/yticks;
                        ctx.fillStyle = '#666'; ctx.fillText(val.toFixed(3), 4, y+4);
                    }

                    // x-axis ticks
                    const xticks = Math.min(8, bins);
                    for(let t=0;t<=xticks;t++){
                        const i = Math.round(t * (bins-1)/xticks);
                        const x = pad + i * bw + bw/2;
                        const v = min + (i+0.5)*binWidth;
                        ctx.fillStyle = '#666'; ctx.fillText((v).toFixed(2), x-12, h-6);
                    }

                    // overlays: poisson pmf (for discrete counts) or exponential pdf (for interarrivals)
                    if(options.overlay === 'poisson' && typeof options.mu === 'number'){
                        const mu = options.mu;
                        // compute Poisson pmf for k values corresponding to bin centers
                        const pmf = [];
                        // we can compute starting p0 then recursive
                        // find k for each bin center
                        for(let i=0;i<bins;i++){
                            const v = Math.round(min + (i+0.5)*binWidth);
                            pmf.push(v);
                        }
                        // compute pmf table up to max k
                        const kmax = Math.max(...pmf);
                        const pvals = new Array(kmax+1).fill(0);
                        pvals[0] = Math.exp(-mu);
                        for(let k=1;k<=kmax;k++) pvals[k] = pvals[k-1] * mu / k;
                        // draw curve scaled to maxVal
                        ctx.beginPath();
                        for(let i=0;i<bins;i++){
                            const k = pmf[i];
                            const prob = (k>=0 && k<pvals.length) ? pvals[k] : 0;
                            const sx = pad + i*bw + bw/2;
                            const sy = h - pad - (prob / maxVal) * (h - 2*pad);
                            if(i===0) ctx.moveTo(sx, sy); else ctx.lineTo(sx, sy);
                        }
                        ctx.strokeStyle = '#ff6b6b'; ctx.lineWidth = 2; ctx.stroke();
                        // draw markers
                        for(let i=0;i<bins;i++){
                            const k = pmf[i]; const prob = (k>=0 && k<pvals.length) ? pvals[k] : 0;
                            const sx = pad + i*bw + bw/2; const sy = h - pad - (prob / maxVal) * (h - 2*pad);
                            ctx.fillStyle = '#ff6b6b'; ctx.beginPath(); ctx.arc(sx, sy, 3, 0, 2*Math.PI); ctx.fill();
                        }
                    }
                    if(options.overlay === 'exponential' && typeof options.lambda === 'number'){
                        const lambda = options.lambda;
                        // compute density values and scale to maxVal
                        ctx.beginPath();
                        const steps = Math.min(200, bins*4);
                        for(let s=0;s<=steps;s++){
                            const xval = min + (s/steps)*(max-min);
                            const pdf = (xval>=0) ? lambda * Math.exp(-lambda * xval) : 0;
                            const sx = pad + (s/steps)*(w-2*pad);
                            const sy = h - pad - (pdf / maxVal) * (h - 2*pad);
                            if(s===0) ctx.moveTo(sx, sy); else ctx.lineTo(sx, sy);
                        }
                        ctx.strokeStyle = '#ff6b6b'; ctx.lineWidth = 2; ctx.stroke();
                    }
                }

                runBtn.addEventListener('click', function(){
                    const lambda = parseFloat(document.getElementById('lambda').value);
                    const T = parseFloat(document.getElementById('T').value);
                    const n = parseInt(document.getElementById('n').value,10);
                    const trials = parseInt(document.getElementById('trials').value,10);
                    if(isNaN(lambda)||isNaN(T)||isNaN(n)||isNaN(trials) || n<=0 || trials<=0){ alert('Please enter valid numeric parameters.'); return; }
                    const p = lambda*T/n;
                    resultsDiv.innerHTML = '<p>Running simulation...</p>';
                    status.textContent = '';

                    // Run simulation with simple loops. Keep UI responsive in chunks.
                    const counts = new Array(trials).fill(0);
                    let trial = 0;

                    function runChunk(){
                        const chunk = 20; // number of trials per chunk to avoid blocking too long
                        const end = Math.min(trials, trial + chunk);
                        for(; trial<end; trial++){
                            let c = 0;
                            for(let i=0;i<n;i++){
                                if(Math.random() < p) c++;
                            }
                            counts[trial] = c;
                        }
                        status.textContent = `Progress: ${Math.round(100*trial/trials)}%`;
                        if(trial < trials){
                            // yield back to event loop
                            setTimeout(runChunk, 0);
                        } else {
                            status.textContent = 'Done';
                            displayResults(lambda, T, n, trials, p, counts);
                        }
                    }
                    runChunk();
                });

                function displayResults(lambda, T, n, trials, p, counts){
                    const empMean = mean(counts);
                    const empVar = variance(counts, empMean);
                    const theor = lambda * T;
                    const html = [];
                    html.push(`<p>Parameters: T=${T}, λ=${lambda}, n=${n}, p=λT/n=${p.toExponential(3)}, trials=${trials}</p>`);
                    html.push('<ul>');
                    html.push(`<li>Empirical mean of counts = ${empMean.toFixed(6)}</li>`);
                    html.push(`<li>Empirical variance of counts = ${empVar.toFixed(6)}</li>`);
                    html.push(`<li>Theoretical (Poisson) mean = variance = λT = ${theor.toFixed(6)}</li>`);
                    html.push('</ul>');
                    resultsDiv.innerHTML = html.join('\n');

                    drawHistogram(countsCanvas, counts, {bins: Math.min(60, Math.max(10, Math.ceil(Math.sqrt(counts.length)))), overlay: 'poisson', mu: theor});

                    // Build interarrival times from one sample realization by placing successes uniformly in subintervals
                    // We'll generate one realization separately
                    const indices = [];
                    for(let i=0;i<n;i++){ if(Math.random() < p) indices.push(i); }
                    const times = indices.map(i => (i + Math.random())*(T/n)).sort((a,b)=>a-b);
                    const interarrivals = [];
                    if(times.length>0){ interarrivals.push(times[0]); for(let k=1;k<times.length;k++) interarrivals.push(times[k]-times[k-1]); }
                    drawHistogram(iaCanvas, interarrivals, {bins: Math.min(40, Math.max(6, Math.ceil(Math.sqrt(interarrivals.length||1)))), overlay: 'exponential', lambda: lambda});
                    // show interarrival summary
                    if(interarrivals.length>0){
                        const mu = mean(interarrivals); const v = variance(interarrivals, mu);
                        const pHtml = `<p>Example realization: events=${times.length}; empirical mean interarrival=${mu.toFixed(6)}; theoretical mean=1/λ=${(1/lambda).toFixed(6)}</p>`;
                        resultsDiv.innerHTML += pHtml;
                    } else {
                        resultsDiv.innerHTML += '<p>Example realization produced no events (very small expected count for this run).</p>';
                    }
                }
            })();
            </script>
            <!-- From Uiverse.io by mobinkakei --> 
             <div class="nav-buttons">
             <a href="Ninth_homework.html">
                <button class="cta mirrored">
                    <span class="second">
                        <svg
                            width="50px"
                            height="20px"
                            viewBox="0 0 66 43"
                            version="1.1"
                            xmlns="http://www.w3.org/2000/svg"
                            xmlns:xlink="http://www.w3.org/1999/xlink"
                        >
                            <g
                                id="arrow"
                                stroke="none"
                                stroke-width="1"
                                fill="none"
                                fill-rule="evenodd"
                            >
                                <path class="one" d="M40.1543933,3.89485454 L43.9763149,0.139296592 C44.1708311,-0.0518420739 44.4826329,-0.0518571125 44.6771675,0.139262789 L65.6916134,20.7848311 C66.0855801,21.1718824 66.0911863,21.8050225 65.704135,22.1989893 C65.7000188,22.2031791 65.6958657,22.2073326 65.6916762,22.2114492 L44.677098,42.8607841 C44.4825957,43.0519059 44.1708242,43.0519358 43.9762853,42.8608513 L40.1545186,39.1069479 C39.9575152,38.9134427 39.9546793,38.5968729 40.1481845,38.3998695 C40.1502893,38.3977268 40.1524132,38.395603 40.1545562,38.3934985 L56.9937789,21.8567812 C57.1908028,21.6632968 57.193672,21.3467273 57.0001876,21.1497035 C56.9980647,21.1475418 56.9959223,21.1453995 56.9937605,21.1432767 L40.1545208,4.60825197 C39.9574869,4.41477773 39.9546013,4.09820839 40.1480756,3.90117456 C40.1501626,3.89904911 40.1522686,3.89694235 40.1543933,3.89485454 Z" fill="#FFFFFF"></path>
                                <path class="two" d="M20.1543933,3.89485454 L23.9763149,0.139296592 C24.1708311,-0.0518420739 24.4826329,-0.0518571125 24.6771675,0.139262789 L45.6916134,20.7848311 C46.0855801,21.1718824 46.0911863,21.8050225 45.704135,22.1989893 C45.7000188,22.2031791 45.6958657,22.2073326 45.6916762,22.2114492 L24.677098,42.8607841 C24.4825957,43.0519059 24.1708242,43.0519358 23.9762853,42.8608513 L20.1545186,39.1069479 C19.9575152,38.9134427 19.9546793,38.5968729 20.1481845,38.3998695 C20.1502893,38.3977268 20.1524132,38.395603 20.1545562,38.3934985 L36.9937789,21.8567812 C37.1908028,21.6632968 37.193672,21.3467273 37.0001876,21.1497035 C36.9980647,21.1475418 36.9959223,21.1453995 36.9937605,21.1432767 L20.1545208,4.60825197 C19.9574869,4.41477773 19.9546013,4.09820839 20.1480756,3.90117456 C20.1501626,3.89904911 20.1522686,3.89694235 20.1543933,3.89485454 Z" fill="#FFFFFF"></path>
                                <path class="three" d="M0.154393339,3.89485454 L3.97631488,0.139296592 C4.17083111,-0.0518420739 4.48263286,-0.0518571125 4.67716753,0.139262789 L25.6916134,20.7848311 C26.0855801,21.1718824 26.0911863,21.8050225 25.704135,22.1989893 C25.7000188,22.2031791 25.6958657,22.2073326 25.6916762,22.2114492 L4.67709797,42.8607841 C4.48259567,43.0519059 4.17082418,43.0519358 3.97628526,42.8608513 L0.154518591,39.1069479 C-0.0424848215,38.9134427 -0.0453206733,38.5968729 0.148184538,38.3998695 C0.150289256,38.3977268 0.152413239,38.395603 0.154556228,38.3934985 L16.9937789,21.8567812 C17.1908028,21.6632968 17.193672,21.3467273 17.0001876,21.1497035 C16.9980647,21.1475418 16.9959223,21.1453995 16.9937605,21.1432767 L0.15452076,4.60825197 C-0.0425130651,4.41477773 -0.0453986756,4.09820839 0.148075568,3.90117456 C0.150162624,3.89904911 0.152268631,3.89694235 0.154393339,3.89485454 Z" fill="#FFFFFF"></path>
                            </g>
                        </svg>
                    </span>
                    <span class="span">PREV</span>
                </button>
            </a>
            </div>
        </main>
        <script src="menu.js"></script>
    </body>
</html>